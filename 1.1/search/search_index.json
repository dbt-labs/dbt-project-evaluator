{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"dbt_project_evaluator","text":"<p>This package highlights areas of a dbt project that are misaligned with dbt Labs' best practices. Specifically, this package tests for:</p> <ol> <li>Modeling - your dbt DAG for modeling best practices</li> <li>Testing - your models for testing best practices</li> <li>Documentation - your models for documentation best practices</li> <li>Structure - your dbt project for file structure and naming best practices</li> <li>Performance - your model materializations for performance best practices</li> <li>Governance - your model governance feature best practices</li> </ol> <p>In addition to tests, this package creates the model <code>int_all_dag_relationships</code> which holds information about your DAG in a tabular format and can be queried using SQL in your Warehouse.</p> <p>Currently, the following adapters are supported:</p> <ul> <li>BigQuery</li> <li>Databricks/Spark</li> <li>PostgreSQL</li> <li>Redshift</li> <li>Snowflake</li> <li>DuckDB</li> <li>Trino (tested with Iceberg connector)</li> <li>AWS Athena (tested manually)</li> <li>Greenplum (tested manually)</li> <li>ClickHouse (tested manually)</li> </ul>"},{"location":"#using-this-package","title":"Using This Package","text":""},{"location":"#cloning-via-dbt-package-hub","title":"Cloning via dbt Package Hub","text":"<p>Check dbt Hub for the latest installation instructions, or read the docs for more information on installing packages.</p>"},{"location":"#additional-setup-for-databrickssparkduckdbredshift","title":"Additional setup for Databricks/Spark/DuckDB/Redshift","text":"<p>In your <code>dbt_project.yml</code>, add the following config:</p> dbt_project.yml<pre><code>dispatch:\n  - macro_namespace: dbt\n    search_order: ['dbt_project_evaluator', 'dbt']\n</code></pre> <p>This is required because the project currently overrides a small number of dbt core macros in order to ensure the project can run across the listed adapters. The overridden macros are in the cross_db_shim directory.</p>"},{"location":"#how-it-works","title":"How It Works","text":"<p>This package will:</p> <ol> <li>Parse your graph object and write it into your warehouse as a series of models (see models/marts/core)</li> <li>Create another series of models that each represent one type of misalignment in your project (below you can find a full list of each misalignment and its accompanying model)</li> <li>Test those models to alert you to the presence of the misalignment</li> </ol> <p>Once you've installed the package, all you have to do is run a <code>dbt build --select package:dbt_project_evaluator</code></p> <p>Each test warning indicates the presence of a type of misalignment. To troubleshoot a misalignment:</p> <ol> <li>Locate the related documentation</li> <li>Query the associated model to find the specific instances of the issue within your project or set up an <code>on-run-end</code> hook to display the rules violations in the dbt logs (see displaying violations in the logs)</li> <li>Either fix the issue(s) or customize the package to exclude them</li> </ol>"},{"location":"#limitations","title":"Limitations","text":""},{"location":"#bigquery-and-databricks","title":"BigQuery and Databricks","text":"<p>BigQuery current support for recursive CTEs is limited and Databricks SQL doesn't support recursive CTEs.</p> <p>For those Data Warehouses, the model <code>int_all_dag_relationships</code> needs to be created by looping CTEs instead. The number of loops is configured with <code>max_depth_dag</code> and defaulted to 9. This means that dependencies between models of more than 9 levels of separation won't show in the model <code>int_all_dag_relationships</code> but tests on the DAG will still be correct. With a number of loops higher than 9 BigQuery sometimes raises an error saying the query is too complex.</p>"},{"location":"ci-check/","title":"Running this package as a CI check","text":"<p>Once you have addressed all current misalignments in your project (either by fixing them or configuring exceptions), you can use this package as a CI check to ensure code changes don't introduce new misalignments. The setup will vary based on whether you are using dbt Cloud or dbt Core, but the general steps are as follows:</p>"},{"location":"ci-check/#1-override-test-severity-with-an-environment-variable","title":"1. Override test severity with an environment variable","text":"<p>By default the tests in this package are configured with \"warn\" severity, we can override that for our CI jobs with an environment variable:</p> <ol> <li> <p>Create an environment variable to define the appropriate severity for each environment. In dbt Cloud, for example, we can easily create an environment variable <code>DBT_PROJECT_EVALUATOR_SEVERITY</code> that is set to \"error\" for the Continuous Integration environment and \"warn\" for all other environments: </p> <p>Note: It is also possible to use an environment variable for dbt Core, but the actual implementation will depend on how dbt is orchestrated.</p> </li> <li> <p>Update you project.yml file to override the default severity for all tests in this package:</p> dbt_project.yml<pre><code>data_tests:\n  dbt_project_evaluator:\n    +severity: \"{{ env_var('DBT_PROJECT_EVALUATOR_SEVERITY', 'warn') }}\"\n</code></pre> <p>Note</p> <p>You could follow a similar process to disable the models in this package for your production environment</p> dbt_project.yml<pre><code>models:\n  dbt_project_evaluator:\n    +enabled: \"{{ env_var('DBT_PROJECT_EVALUATOR_ENABLED', 'true') | lower == 'true' | as_bool }}\"\n</code></pre> </li> </ol>"},{"location":"ci-check/#2-run-this-package-for-each-pull-request","title":"2. Run this package for each pull request","text":"<p>Now, you can run this package as a step of your CI job/pipeline. In dbt Cloud, for example, you could update the commands of your CI job to:</p> <pre><code>dbt build --select state:modified+ --exclude package:dbt_project_evaluator\ndbt build --select package:dbt_project_evaluator\n</code></pre> <p>Or, if you've configured any exceptions, to:</p> <pre><code>dbt build --select state:modified+ --exclude package:dbt_project_evaluator\ndbt build --select package:dbt_project_evaluator dbt_project_evaluator_exceptions\n</code></pre> <p></p> <p>Note</p> <p>Ensure you have properly set up your dbt Cloud CI job using deferral and a webhook trigger by following this documentation.</p>"},{"location":"contributing/","title":"Contributing","text":"<p>If you'd like to add models to flag new areas, please update this documentation and add an integration test (more details here)</p>"},{"location":"contributing/#running-docs-locally","title":"Running docs locally","text":"<p>Docs are generated using Material for MkDocs. To test them locally, run the following commands (use a Python virtual environment):</p> <pre><code>pip install mkdocs-material\nmkdocs serve\n</code></pre> <p>Docs are then automatically pushed to the website as part of our CI/CD process. We use mike as part of the process to publish different versions of the docs.</p>"},{"location":"contributing/#recommended-vscode-extensions-to-help-with-writing-docs","title":"Recommended VSCode extensions to help with writing docs","text":"<ul> <li> <p>markdownlint</p> <ul> <li>Highlight issues with the Markdown code</li> <li> <p>The config used in <code>.vscode/settings.json</code> is the following:</p> <pre><code>\"markdownlint.config\": {\n    \"ul-indent\": {\"indent\": 4},\n    \"MD036\": false,\n    \"MD046\": false,\n}\n</code></pre> </li> </ul> </li> <li> <p>Mardown All in One</p> <ul> <li>Makes it easy to paste links on top of text to create markdown links</li> </ul> </li> </ul>"},{"location":"querying-the-dag/","title":"Querying the DAG with SQL","text":"<p>The model <code>int_all_dag_relationships</code> (source), created with the package, lists all the dbt nodes (models, exposures, sources, metrics, seeds, snapshots) along with all their dependencies (including indirect ones) and the path between them.</p> <p>Building additional models and snapshots on top of this model could allow:</p>"},{"location":"querying-the-dag/#creating-a-dashboard-that-provides-info-on-your-project","title":"Creating a dashboard that provides info on your project","text":"<ul> <li>a list of all the sources used by a given exposure</li> <li>a list of all the exposures or metrics using a given source</li> <li>the dependencies between different models</li> </ul>"},{"location":"querying-the-dag/#building-metricskpis-on-top-of-a-dbt-project","title":"Building metrics/KPIs on top of a dbt project","text":"<ul> <li>evolution of the number of models over time</li> <li>evolution of the number of metrics and exposures over time</li> </ul>"},{"location":"querying-the-dag/#getting-insights-on-potential-refactoring-work","title":"Getting insights on potential refactoring work","text":"<ul> <li>identifying models with a lot of lines of code</li> <li>identifying the models with the highest level of complexity leveraging the column <code>sql_complexity</code> from the table <code>int_all_graph_resources</code>, based on the weights defined in the <code>token_costs</code> variable</li> <li>looking at the longest \"chains\" of models in a project</li> <li>reviewing models with many/few direct dependents</li> <li>identifying potential bottlenecks</li> </ul>"},{"location":"querying-the-dag/#defining-additional-tests-that-match-your-exact-requirements","title":"Defining additional tests that match your exact requirements","text":"<ul> <li>writing a model with <code>ref(int_all_dag_relationships)</code> with custom tests added for a specific use case</li> </ul>"},{"location":"rules/","title":"List of the rules currently defined","text":"Type Friendly name fact name Modeling Staging Models Dependent on Other Staging Models <code>fct_staging_dependent_on_staging</code> Modeling Source Fanout <code>fct_source_fanout</code> Modeling Rejoining of Upstream Concepts <code>fct_rejoining_of_upstream_concepts</code> Modeling Model Fanout <code>fct_model_fanout</code> Modeling Downstream Models Dependent on Source <code>fct_marts_or_intermediate_dependent_on_source</code> Modeling Direct Join to Source <code>fct_direct_join_to_source</code> Modeling Duplicate Sources <code>fct_duplicate_sources</code> Modeling Hard Coded References <code>fct_hard_coded_references</code> Modeling Multiple Sources Joined <code>fct_multiple_sources_joined</code> Modeling Root Models <code>fct_root_models</code> Modeling Staging Models Dependent on Downstream Models <code>fct_staging_dependent_on_marts_or_intermediate</code> Modeling Unused Sources <code>fct_unused_sources</code> Modeling Models with Too Many Joins <code>fct_too_many_joins</code> Testing Missing Primary Key Tests <code>fct_missing_primary_key_tests</code> Testing Missing Source Freshness <code>fct_sources_without_freshness</code> Testing Test Coverage <code>fct_test_coverage</code> Documentation Undocumented Models <code>fct_undocumented_models</code> Documentation Documentation Coverage <code>fct_documentation_coverage</code> Documentation Undocumented Source Tables <code>fct_undocumented_source_tables</code> Documentation Undocumented Sources <code>fct_undocumented_sources</code> Structure Test Directories <code>fct_test_directories</code> Structure Model Naming Conventions <code>fct_model_naming_conventions</code> Structure Source Directories <code>fct_source_directories</code> Structure Model Directories <code>fct_model_directories</code> Performance Chained View Dependencies <code>fct_chained_views_dependencies</code> Performance Exposure Parents Materializations <code>fct_exposure_parents_materializations</code> Governance Public Models Without Contracts <code>fct_public_models_without_contracts</code> Governance Exposures Dependent on Private Models <code>fct_exposures_dependent_on_private_models</code> Governance Undocumented Public Models <code>fct_undocumented_public_models</code>"},{"location":"customization/customization/","title":"Disabling checks from the package","text":"<p>Note</p> <p>This section is describing how to completely deactivate tests from the package. If you are looking to deactivate models/sources from being tested, you can look at excluding packages and paths</p> <p>All the tests done as part of the package are tied to <code>fct</code> models.</p> <p>If there is a particular test or set of tests that you do not want this package to execute, you can disable the corresponding <code>fct</code> models as you would any other model in your <code>dbt_project.yml</code> file</p> dbt_project.yml<pre><code>models:\n  dbt_project_evaluator:\n    marts:\n      data_tests:\n        # disable entire test coverage suite\n        +enabled: false\n      dag:\n        # disable single DAG model\n        fct_model_fanout:\n          +enabled: false\n</code></pre>"},{"location":"customization/exceptions/","title":"Configuring exceptions to the rules","text":"<p>While the rules defined in this package are considered best practices, we realize that there might be exceptions to those rules and people might want to exclude given results to get passing tests despite not following all the recommendations.</p> <p>An example would be excluding all models with names matching with <code>stg_..._unioned</code> from <code>fct_multiple_sources_joined</code> as we might want to union 2 different tables representing the same data in some of our staging models and we don't want the test to fail for those models.</p> <p>The package offers the ability to define a seed called <code>dbt_project_evaluator_exceptions.csv</code> to list those exceptions we don't want to be reported. This seed must contain the following columns:</p> <ul> <li><code>fct_name</code>: the name of the fact table for which we want to define exceptions (Please note that it is not possible to exclude specific models for all the <code>coverage</code> tests, but there are variables available to configure those to the particular users' needs)</li> <li><code>column_name</code>: the column name from <code>fct_name</code> we will be looking at to define exceptions</li> <li><code>id_to_exclude</code>: the values (or <code>like</code> pattern) we want to exclude for <code>column_name</code></li> <li><code>comment</code>: a field where people can document why a given exception is legitimate</li> </ul> <p>The following section describes the steps to follow to configure exceptions.</p>"},{"location":"customization/exceptions/#1-create-a-new-seed","title":"1. Create a new seed","text":"<p>With our previous example, the seed <code>dbt_project_evaluator_exceptions.csv</code> would look like:</p> <pre><code>fct_name,column_name,id_to_exclude,comment\nfct_multiple_sources_joined,child,stg_%_unioned,Models called _unioned can union multiple sources\n</code></pre> <p>which looks like the following when loaded in the warehouse</p> fct_name column_name id_to_exclude comment fct_multiple_sources_joined child stg_%_unioned Models called _unioned can union multiple sources"},{"location":"customization/exceptions/#2-deactivate-the-seed-from-the-original-package","title":"2. Deactivate the seed from the original package","text":"<p>Only a single seed can exist with a given name. When using a custom one, we need to deactivate the blank one from the package by adding the following to our <code>dbt_project.yml</code></p> dbt_project.yml<pre><code>seeds:\n  dbt_project_evaluator:\n    dbt_project_evaluator_exceptions:\n      +enabled: false\n</code></pre>"},{"location":"customization/exceptions/#3-run-the-seed-and-the-package","title":"3. Run the seed and the package","text":"<p>We then run both the seed and the package by executing the following command:</p> <pre><code>dbt build --select package:dbt_project_evaluator dbt_project_evaluator_exceptions\n</code></pre>"},{"location":"customization/excluding-packages-and-paths/","title":"Excluding packages or sources/models based on their path","text":"<p>Note</p> <p>This section is describing how to entirely exclude models/sources and packages to be evaluated. If you want to document exceptions to the rules, see the section on exceptions and if you want to deactivate entire tests you can follow instructions from this page</p> <p>There might be cases where you want to exclude models/sources from being tested:</p> <ul> <li>they could come from a package for which you have no control over</li> <li>you might be refactoring your project and wanting to exclude entire folders to follow best-practices in the new models</li> </ul> <p>In that case, this package provides the ability to exclude whole packages and/or models and sources based on their path</p>"},{"location":"customization/excluding-packages-and-paths/#configuration","title":"Configuration","text":"<p>The variables <code>exclude_packages</code> and <code>exclude_paths_from_project</code> allow you to define a list of regex patterns to exclude from being reported as errors.</p> <ul> <li><code>exclude_packages</code> accepts a list of package names to exclude from the tool. To exclude all packages except the current project, you can set it to <code>[\"all\"]</code></li> <li><code>exclude_paths_from_project</code> accepts a list of regular expressions of paths to exclude for the current project<ul> <li>for models, the regex provided will try to match the pattern in the string <code>&lt;path/to/model.sql&gt;</code>, allowing to exclude packages, but also whole folders or individual models</li> <li>for sources, the regex will try to match the pattern in <code>&lt;path/to/sources.yml&gt;:&lt;source_name&gt;.&lt;source_table_name&gt;</code> (the pattern is different than for models because the path itself doesn't let us exclude individual sources)</li> </ul> </li> </ul> <p>Note</p> <p>We currently don't allow excluding metrics and exposures, as if those need to be entirely excluded they could be deactivated from the project.</p> <p>If you have a specific use case requiring this ability, please raise a GitHub issue to explain the situation you'd like to solve and we can revisit this decision !</p>"},{"location":"customization/excluding-packages-and-paths/#example-to-exclude-a-whole-package","title":"Example to exclude a whole package","text":"dbt_project.yml<pre><code>vars:\n  exclude_packages: [\"upstream_package\"]\n</code></pre>"},{"location":"customization/excluding-packages-and-paths/#example-to-exclude-modelssources-in-a-given-path","title":"Example to exclude models/sources in a given path","text":"dbt_project.yml<pre><code>vars:\n  exclude_paths_from_project: [\"models/legacy/\"]\n</code></pre>"},{"location":"customization/excluding-packages-and-paths/#example-to-exclude-both-a-package-and-modelssources-in-2-different-paths","title":"Example to exclude both a package and models/sources in 2 different paths","text":"dbt_project.yml<pre><code>vars:\n  exclude_packages: [\"upstream_package\"]\n  exclude_paths_from_project: [\"models/legacy/\", \"/my_date_spine.sql\"]\n</code></pre>"},{"location":"customization/excluding-packages-and-paths/#tips-and-tricks","title":"Tips and tricks","text":"<p>Regular expressions are very powerful but can become complex. After defining your value for <code>exclude_paths_from_project</code>, we recommend running the package and inspecting the model <code>int_all_graph_resources</code>, checking if the value in the column <code>is_excluded</code> matches your expectation.</p> <p>A useful tool to debug regular expression is regex101. You can provide a pattern and a list of strings to see which ones actually match the pattern.</p>"},{"location":"customization/issues-in-log/","title":"Displaying violations in the logs","text":"<p>This package provides a macro that can be executed via an <code>on-run-end</code> hook to display the package results in the logs in addition to storing those in the Data Warehouse.</p> <p>To use it, you can add the following line in your <code>dbt_project.yml</code>:</p> <pre><code>on-run-end: \"{{ dbt_project_evaluator.print_dbt_project_evaluator_issues() }}\"\n</code></pre> <p>The macro accepts two parameters:</p> <ul> <li>to pick between 2 types of formatting, set <code>format='table'</code> (default) or <code>format='csv'</code></li> <li>to add quotes to the database and schema (default = no quote), set <code>quote='`'</code> or <code>quote='\"'</code></li> </ul>"},{"location":"customization/issues-in-log/#logging-your-custom-rules","title":"Logging your custom rules","text":"<p>You can also log the results of your custom rules by applying <code>dbt_project_evaluator.is_empty</code> to the custom models.</p> <pre><code>models:\n  - name: my_custom_rule_model\n    description: This is my custom project evaluator check \n    data_tests:\n      - dbt_project_evaluator.is_empty\n</code></pre>"},{"location":"customization/overriding-variables/","title":"Overriding Variables","text":"<p>Currently, this package uses different variables to adapt the models to your objectives and naming conventions. They can all be updated directly in <code>dbt_project.yml</code></p>"},{"location":"customization/overriding-variables/#testing-and-documentation-variables","title":"Testing and Documentation Variables","text":"variable description default <code>test_coverage_target</code> the minimum acceptable test coverage percentage 100% <code>documentation_coverage_target</code> the minimum acceptable documentation coverage percentage 100% <code>primary_key_test_macros</code> the set(s) of dbt tests used to check validity of a primary key <code>[[\"dbt.test_unique\", \"dbt.test_not_null\"], [\"dbt_utils.test_unique_combination_of_columns\"]]</code> <code>enforced_primary_key_node_types</code> the set of node types for you you would like to enforce primary key test coverage. Valid options to include are <code>model</code>, <code>source</code>, <code>snapshot</code>, <code>seed</code> <code>[\"model\"]</code> <p>Usage notes for <code>primary_key_test_macros:</code></p> <p>The <code>primary_key_test_macros</code> variable determines how the <code>fct_missing_primary_key_tests</code> (source) model evaluates whether the models in your project are properly tested for their grain. This variable is a list and each entry must be a list of test names in <code>project_name.test_macro_name</code> format.</p> <p>For each entry in the parent list, the logic in <code>int_model_test_summary</code> will evaluate whether each model has all of the tests in that entry applied. If a model meets the criteria of any of the entries in the parent list, it will be considered a pass. The default behavior for this package will check for whether each model has either:</p> <ol> <li>Both the <code>not_null</code> and <code>unique</code> tests applied to a single column OR</li> <li>The <code>dbt_utils.unique_combination_of_columns</code> applied to the model.</li> </ol> <p>Each set of test(s) that define a primary key requirement must be grouped together in a sub-list to ensure they are evaluated together (e.g. [<code>dbt.test_unique</code>, <code>dbt.test_not_null</code>] ).</p> <p>While it's not explicitly tested in this package, we strongly encourage adding a <code>not_null</code> test on each of the columns listed in the <code>dbt_utils.unique_combination_of_columns</code> tests. Alternatively, on Snowflake, consider <code>dbt_constraints.test_primary_key</code> in the dbt Constraints package, which enforces each field in the primary key is non null.</p> dbt_project.yml<pre><code># set your test and doc coverage to 75% instead\n# use the dbt_constraints.test_primary_key test to check for validity of your primary keys\n\nvars:\n  dbt_project_evaluator:\n    documentation_coverage_target: 75\n    test_coverage_target: 75\n    primary_key_test_macros: [[\"dbt_constraints.test_primary_key\"]]\n</code></pre>"},{"location":"customization/overriding-variables/#dag-variables","title":"DAG Variables","text":"variable description default <code>models_fanout_threshold</code> threshold for unacceptable model fanout for <code>fct_model_fanout</code> 3 models <code>too_many_joins_threshold</code> threshold for the number of references to flag in <code>fct_too_many_joins</code> 7 references dbt_project.yml<pre><code># set your model fanout threshold to 10 instead of 3 and too many joins from 6 instead of 7\n\nvars:\n  dbt_project_evaluator:\n    models_fanout_threshold: 10\n    too_many_joins_threshold: 6\n</code></pre>"},{"location":"customization/overriding-variables/#naming-convention-variables","title":"Naming Convention Variables","text":"variable description default <code>model_types</code> a list of the different types of models that define the layers of your dbt project staging, intermediate, marts, other <code>staging_folder_name</code> the name of the folder that contains your staging models staging <code>intermediate_folder_name</code> the name of the folder that contains your intermediate models intermediate <code>marts_folder_name</code> the name of the folder that contains your marts models marts <code>staging_prefixes</code> the list of acceptable prefixes for your staging models stg_ <code>intermediate_prefixes</code> the list of acceptable prefixes for your intermediate models int_ <code>marts_prefixes</code> the list of acceptable prefixes for your marts models fct_, dim_ <code>other_prefixes</code> the list of acceptable prefixes for your other models rpt_ <p>The <code>model_types</code>, <code>&lt;model_type&gt;_folder_name</code>, and <code>&lt;model_type&gt;_prefixes</code> variables allow the package to check if models in the different layers are in the correct folders and have a correct prefix in their name. The default model types are the ones we recommend in our dbt Labs Style Guide.</p> <p>If your model types are different, you can update the <code>model_types</code> variable and create new variables for <code>&lt;model_type&gt;_folder_name</code> and/or <code>&lt;model_type&gt;_prefixes</code>.</p> dbt_project.yml<pre><code># add an additional model type \"util\"\n\nvars:\n  dbt_project_evaluator:\n    model_types: ['staging', 'intermediate', 'marts', 'other', 'util']\n    util_folder_name: 'util'\n    util_prefixes: ['util_']\n</code></pre>"},{"location":"customization/overriding-variables/#performance-variables","title":"Performance Variables","text":"variable description default <code>chained_views_threshold</code> threshold for unacceptable length of chain of views for <code>fct_chained_views_dependencies</code> 4 dbt_project.yml<pre><code>vars:\n  dbt_project_evaluator:\n    # set your chained views threshold to 8 instead of 4\n    chained_views_threshold: 8\n</code></pre>"},{"location":"customization/overriding-variables/#sql-code-analysis","title":"SQL code analysis","text":"variable description default <code>comment_chars</code> a list of strings used for inline comments <code>[\"--\"]</code> <code>token_costs</code> a dictionary of SQL tokens (words) and associated complexity weight, used to estimate models complexity see in the <code>dbt_project.yml</code> file of the package"},{"location":"customization/overriding-variables/#execution","title":"Execution","text":"variable description default <code>max_depth_dag</code> limits the maximum distance between nodes calculated in <code>int_all_dag_relationships</code> 9 for bigquery and spark, -1 for other adatpters <code>insert_batch_size</code> number of records inserted per batch when unpacking the graph into models 10000 <p>Note on max_depth_dag</p> <p>The default behavior for limiting the relationships calculated in the <code>int_all_dag_relationships</code> model differs depending on your adapter.</p> <ul> <li>For Bigquery &amp; Spark/Databricks the maximum distance between two nodes in your DAG, calculated in <code>int_all_dag_relationships</code>, is set by the <code>max_depth_dag</code> variable, which is defaulted to 9. So by default, <code>int_all_dag_relationships</code> contains a row for every path less than or equal to 9 nodes in length between two nodes in your DAG. This is because these adapters do not currently support recursive SQL, and queries often fail on more than 9 recursive joins.</li> <li>For all other adapters <code>int_all_dag_relationships</code> by default contains a row for every single path between two nodes in your DAG. If you experience long runtimes for the <code>int_all_dag_relationships</code> model, you may consider limiting the length of your generated DAG paths. To do this, set <code>max_depth_dag: {{ whatever limit you want to enforce }}</code>. The value of <code>max_depth_dag</code> must be greater than 2 for all DAG tests to work, and greater than <code>chained_views_threshold</code> to ensure your performance tests to work. By default, the value of this variable for these adapters is -1, which the package interprets as \"no limit\".</li> </ul> dbt_project.yml<pre><code>vars:\n  dbt_project_evaluator:\n    # update the number of records inserted from the graph from 10,000 to 500 to reduce query size\n    insert_batch_size: 500\n    # set the maximum distance between nodes to 5 \n    max_depth_dag: 5\n</code></pre>"},{"location":"customization/querying-columns-names-and-descriptions/","title":"Querying columns names and descriptions with SQL","text":"<p>The model <code>stg_columns</code> (source), created with the package, lists all the columns configured in all the dbt nodes (models, sources, tests, snapshots).</p> <p>It will not list the columns of the models that have not explicitly been added to the YAML files.</p> <p>You can use this model to help with questions such as:</p> <ul> <li>Are there columns with the same name in different nodes?</li> <li>Do any columns in the YAML configuration lack descriptions?</li> <li>Do any columns share the same name but have different descriptions?</li> <li>Are there columns with names that match a specific pattern (regex)?</li> <li>Have any prohibited names been used for columns?</li> </ul>"},{"location":"customization/querying-columns-names-and-descriptions/#defining-additional-tests-that-match-your-exact-requirements","title":"Defining additional tests that match your exact requirements","text":"<p>You can create a custom test against  <code>{{ ref(stg_columns) }}</code> to test for your specific check! When running the package you'd need to make sure to also include children of the package's models by using the <code>package:dbt_project_evalutator+</code> selector.</p>"},{"location":"rules/documentation/","title":"Documentation","text":""},{"location":"rules/documentation/#documentation-coverage","title":"Documentation Coverage","text":"<code>fct_documentation_coverage</code> <pre><code>with\n\nmodels as (\n    select * from {{ ref('int_all_graph_resources') }}\n    where resource_type = 'model'\n    and not is_excluded\n),\n\nconversion as (\n    select\n        resource_id,\n        case when is_described then 1 else 0 end as is_described_model,\n        {% for model_type in var('model_types') %}\n            case when model_type = '{{ model_type }}' then 1.0 else NULL end as is_{{ model_type }}_model,\n            case when is_described and model_type = '{{ model_type }}' then 1.0 else 0 end as is_described_{{ model_type }}_model{% if not loop.last %},{% endif %}\n        {% endfor %}\n\n    from models\n),\n\nfinal as (\n    select\n        {{ dbt.current_timestamp() if target.type != 'trino' else 'current_timestamp(6)' }} as measured_at,\n        cast(count(*) as {{ dbt.type_int() }}) as total_models,\n        cast(sum(is_described_model) as {{ dbt.type_int() }}) as documented_models,\n        round(sum(is_described_model) * 100.00 / count(*), 2) as documentation_coverage_pct,\n        {% for model_type in var('model_types') %}\n            round(\n                {{ dbt_utils.safe_divide(\n                    numerator = \"sum(is_described_\" ~ model_type ~ \"_model) * 100\", \n                    denominator = \"count(is_\" ~ model_type ~ \"_model)\"\n                ) }}\n            , 2) as {{ model_type }}_documentation_coverage_pct{% if not loop.last %},{% endif %}\n        {% endfor %}\n\n    from models\n    left join conversion\n    on models.resource_id = conversion.resource_id\n)\n\nselect * from final\n</code></pre> <p><code>fct_documentation_coverage</code> (source) calculates the percent of enabled models in the project that have a configured description.</p> <p>This model will raise a <code>warn</code> error on a <code>dbt build</code> or <code>dbt test</code> if the <code>documentation_coverage_pct</code> is less than 100%. You can set your own threshold by overriding the <code>documentation_coverage_target</code> variable. See overriding variables section.</p> <p>Reason to Flag</p> <p>Good documentation for your dbt models will help downstream consumers discover and understand the datasets which you curate for them. The documentation for your project includes model code, a DAG of your project, any tests you've added to a column, and more.</p> <p>How to Remediate</p> <p>Apply a text description in the model's <code>.yml</code> entry, or create a docs block in a markdown file, and use the <code>{{ doc() }}</code> function in the model's <code>.yml</code> entry.</p> <p>Tip</p> <p>We recommend that every model in your dbt project has at minimum a model-level description. This ensures that each model's purpose is clear to other developers and stakeholders when viewing the dbt docs site.</p>"},{"location":"rules/documentation/#undocumented-models","title":"Undocumented Models","text":"<p><code>fct_undocumented_models</code> (source) lists every model with no description configured.</p> <p>Reason to Flag</p> <p>Good documentation for your dbt models will help downstream consumers discover and understand the datasets which you curate for them. The documentation for your project includes model code, a DAG of your project, any tests you've added to a column, and more.</p> <p>How to Remediate</p> <p>Apply a text description in the model's <code>.yml</code> entry, or create a docs block in a markdown file, and use the <code>{{ doc() }}</code> function in the model's <code>.yml</code> entry.</p> <p>Tip</p> <p>We recommend that every model in your dbt project has at minimum a model-level description. This ensures that each model's purpose is clear to other developers and stakeholders when viewing the dbt docs site. Missing documentation should be addressed first for marts models, then for the rest of your project, to ensure that stakeholders in the organization can understand the data which is surfaced to them.</p>"},{"location":"rules/documentation/#undocumented-source-tables","title":"Undocumented Source Tables","text":"<p><code>fct_undocumented_source_tables</code> (source) lists every source table with no description configured.</p> <p>Reason to Flag</p> <p>Good documentation for your dbt sources will help contributors to your project understand how and when data is loaded into your warehouse.</p> <p>How to Remediate</p> <p>Apply a text description in the table's <code>.yml</code> entry, or create a docs block in a markdown file, and use the <code>{{ doc() }}</code> function in the table's <code>.yml</code> entry. <pre><code>sources:\n  - name: my_source\n    tables:\n      - name: my_table\n        description: This is the source table description\n</code></pre></p>"},{"location":"rules/documentation/#undocumented-sources","title":"Undocumented Sources","text":"<p><code>fct_undocumented_sources</code> (source) lists every source with no description configured.</p> <p>Reason to Flag</p> <p>Good documentation for your dbt sources will help contributors to your project understand how and when data is loaded into your warehouse.</p> <p>How to Remediate</p> <p>Apply a text description in the source's <code>.yml</code> entry, or create a docs block in a markdown file, and use the <code>{{ doc() }}</code> function in the source's <code>.yml</code> entry. <pre><code>sources:\n  - name: my_source\n    description: This is the source description\n    tables:\n      - name: my_table\n</code></pre></p>"},{"location":"rules/governance/","title":"Governance","text":"<p>This set of rules provides checks on your project against dbt Labs' recommended best proactices for adding model governance features in dbt versions 1.5 and above.</p>"},{"location":"rules/governance/#public-models-without-contracts","title":"Public models without contracts","text":"<p><code>fct_public_models_without_contract</code> (source) shows each model with <code>access</code> configured as public, but is not a contracted model.</p> <p>Example</p> <p><code>report_1</code> is defined as a public model, but does not have the <code>contract</code> configuration to enforce its datatypes.</p> <pre><code># public model without a contract\nmodels:\n  - name: report_1\n    description: very important OKR reporting model\n    access: public\n</code></pre> <p>Reason to Flag</p> <p>Models with public access are free to be consumed by any downstream consumer. This implies a need for better guarantees around the model's data types and columns. Adding a contract to the model will ensure that the model always conforms to the datatypes, columns, and other constraints you expect.</p> <p>How to Remediate</p> <p>Edit the yml to include the contract configuration, as well as a column entry for all columns output by the model, including their datatype. While not strictly required for defining a contracts, it's best practice to also document each column as well.</p> <pre><code>models:\n  - name: report_1\n    description: very important OKR reporting model\n    access: public\n    config:\n      contract:\n        enforced: true\n    columns:\n      - name: id \n        data_type: integer\n</code></pre>"},{"location":"rules/governance/#undocumented-public-models","title":"Undocumented public models","text":"<p><code>fct_undocumented_public_models</code> (source) shows each model with <code>access</code> configured as public that is not fully documented. This check is similar to <code>fct_undocumented_models</code> (source), but is a stricter check that will highlight any public model that does not have a model-level description as well descriptions on each of its columns.</p> <p>Example</p> <p><code>report_1</code> is defined as a public model, but does not descriptions on the model and each column.</p> <pre><code># public model without documentation\nmodels:\n  - name: report_1\n    access: public\n    columns:\n      - name: id\n</code></pre> <p>Reason to Flag</p> <p>Models with public access are free to be consumed by any downstream consumer. This implies a need for higher standards for the model's usability for those cosumers. Adding more documentation can help consumers understand how they should leverage the data from your public model.</p> <p>How to Remediate</p> <p>Edit the yml to include a model level description,  as well as a column entry with a description for all columns output by the model. While not strictly required for public models, these should likely also have contracts added as well. (See above rule)</p> <pre><code>models:\n  - name: report_1\n    description: very important OKR reporting model\n    access: public\n    columns:\n      - name: id \n        description: the primary key of my OKR model\n</code></pre>"},{"location":"rules/governance/#exposures-dependent-on-private-models","title":"Exposures dependent on private models","text":"<p><code>fct_exposures_dependent_on_private_models</code> (source) shows each relationship between a resource and an exposure where the parent resource is not a model with <code>access</code> configured as public.</p> <p>Example</p> <p>Here's a sample DAG that shows direct exposure relationships.</p> <p></p> <p>If this were the yml for these two parent models, <code>dim_model_7</code> would be flagged by this check, as it is not a public model.</p> <pre><code>models:\n  - name: fct_model_6\n    description: very important OKR reporting model\n    access: public\n    config:\n      materialized: table\n      contract:\n        enforced: true\n    columns:\n      - name: id \n        description: the primary key of my OKR model\n        data_type: integer\n  - name: dim_model_7\n    description: excellent model\n    access: private\n</code></pre> <p>Reason to Flag</p> <p>Exposures show how and where your data is being consumed in downstream tools. These tools should read from public, trusted, contracted data sources. All models that are exposed to other tools should have that codified in their <code>access</code> configuration.</p> <p>How to Remediate</p> <p>Edit the yml to include fully expose the models that your exposures depend on. This rule will only flag models that are not <code>public</code>, but best practices suggest you should also fully document and contracts these public models as well.</p> <pre><code>models:\n  - name: fct_model_6\n    description: very important OKR reporting model\n    access: public\n    config:\n      materialized: table\n      contract:\n        enforced: true\n    columns:\n      - name: id \n        description: the primary key of my OKR model\n        data_type: integer\n  - name: dim_model_7\n    description: excellent model\n    access: public\n</code></pre>"},{"location":"rules/modeling/","title":"Modeling","text":""},{"location":"rules/modeling/#direct-join-to-source","title":"Direct Join to Source","text":"<p><code>fct_direct_join_to_source</code> (source) shows each parent/child relationship where a model has a reference to both a model and a source.</p> <p>Example</p> <p><code>int_model_4</code> is pulling in both a model and a source.</p> <p></p> <p>Reason to Flag</p> <p>We highly recommend having a one-to-one relationship between sources and their corresponding <code>staging</code> model, and not having any other model reading from the source. Those <code>staging</code> models are then the ones read from by the other downstream models.</p> <p>This allows renaming your columns and doing minor transformation on your source data only once and being consistent across all the models that will consume the source data.</p> <p>How to Remediate</p> <p>In our example, we would want to:</p> <ol> <li>create a <code>staging</code> model for our source data if it doesn't exist already</li> <li>and join this <code>staging</code> model to other ones to create our downstream transformation instead of using the source</li> </ol> <p>After refactoring your downstream model to select from the staging layer, your DAG should look like this:</p> <p></p>"},{"location":"rules/modeling/#downstream-models-dependent-on-source","title":"Downstream Models Dependent on Source","text":"<p><code>fct_marts_or_intermediate_dependent_on_source</code> (source) shows each downstream model (<code>marts</code> or <code>intermediate</code>) that depends directly on a source node.</p> <p>Example</p> <p><code>fct_model_9</code>, a marts model, builds from <code>source_1.table_5</code> a source.</p> <p></p> <p>Reason to Flag</p> <p>We very strongly believe that a staging model is the atomic unit of data modeling. Each staging model bears a one-to-one relationship with the source data table it represents. It has the same granularity, but the columns have been renamed, recast, or usefully reconsidered into a consistent format. With that in mind, if a <code>marts</code> or <code>intermediate</code> type model joins directly to a <code>{{ source() }}</code> node, there likely is a missing model that needs to be added.</p> <p>How to Remediate</p> <p>Add the reference to the appropriate <code>staging</code> model to maintain an abstraction layer between your raw data and your downstream data artifacts.</p> <p>After refactoring your downstream model to select from the staging layer, your DAG should look like this:</p> <p></p>"},{"location":"rules/modeling/#duplicate-sources","title":"Duplicate Sources","text":"<p><code>fct_duplicate_sources</code> (source) shows each database object that corresponds to more than one source node.</p> <p>Example</p> <p>Imagine you have two separate source nodes - <code>source_1.table_5</code> and <code>source_1.raw_table_5</code>.</p> <p></p> <p>But both source definitions point to the exact same location in your database - <code>real_database</code>.<code>real_schema</code>.<code>table_5</code>.</p> <pre><code>sources:\n  - name: source_1\n    schema: real_schema\n    database: real_database\n    tables:\n      - name: table_5\n      - name: raw_table_5\n        identifier: table_5\n</code></pre> <p>Reason to Flag</p> <p>If you dbt project has multiple source nodes pointing to the exact same location in your data warehouse, you will have an inaccurate view of your lineage.  </p> <p>How to Remediate</p> <p>Combine the duplicate source nodes so that each source database location only has a single source definition in your dbt project.</p>"},{"location":"rules/modeling/#hard-coded-references","title":"Hard Coded References","text":"<p><code>fct_hard_coded_references</code> (source) shows each instance where a model contains hard coded reference(s).</p> <p>Example</p> <p><code>fct_orders</code> uses hard coded direct relation references (<code>my_db.my_schema.orders</code> and <code>my_schema.customers</code>).</p> fct_orders.sql<pre><code>with orders as (\n    select * from my_db.my_schema.orders\n),\ncustomers as (\n    select * from my_schema.customers\n)\nselect\n    orders.order_id,\n    customers.name\nfrom orders\nleft join customers on\n  orders.customer_id = customers.id\n</code></pre> <p>Reason to Flag</p> <p>Always use the <code>ref</code> function when selecting from another model and the <code>source</code> function when selecting from raw data, rather than using the direct relation reference (e.g. <code>my_schema.my_table</code>). Direct relation references are determined via regex mapping here.</p> <p>The <code>ref</code> and <code>source</code> functions are part of what makes dbt so powerful! Using these functions allows dbt to infer dependencies (and check that you haven't created any circular dependencies), properly generate your DAG, and ensure that models are built in the correct order. This also ensures that your current model selects from upstream tables and views in the same environment that you're working in.</p> <p>How to Remediate</p> <p>For each hard coded reference:</p> <ul> <li>if the hard coded reference is to a model, update the sql to instead use the ref function</li> <li>if the hard coded reference is to raw data, create any needed sources and update the sql to instead use the source function</li> </ul> <p>For the above example, our updated <code>fct_orders.sql</code> file would look like:</p> fct_orders.sql<pre><code>with orders as (\n    select * from {{ ref('orders') }}\n),\ncustomers as (\n    select * from {{ ref('customers') }}\n)\nselect\n    orders.order_id,\n    customers.name\nfrom orders\nleft join customers on\n  orders.customer_id = customers.id\n</code></pre>"},{"location":"rules/modeling/#model-fanout","title":"Model Fanout","text":"<p><code>fct_model_fanout</code> (source) shows all parents with more than 3 direct leaf children. You can set your own threshold for model fanout by overriding the <code>models_fanout_threshold</code> variable. See overriding variables section.</p> <p>Example</p> <p><code>fct_model</code> has three direct leaf children.</p> <p></p> <p>Reason to Flag</p> <p>This might indicate some transformations should move to the BI layer, or a common business transformations should be moved upstream.</p> <p>Exceptions</p> <p>Some BI tools are better than others at joining and data exploration. For example, with Looker you could end your DAG after marts (i.e. fcts &amp; dims) and join those artifacts together (with a little know how and setup time) to make your reports. For others, like Tableau, model fanouts might be more beneficial, as this tool prefers big tables over joins, so predefining some reports is usually more performant.</p> <p>To exclude specific cases, check out the instructions in Configuring exceptions to the rules.</p> <p>How to Remediate</p> <p>Queries and transformations can move around between dbt and the BI tool, so how do we try to stay effortful in what we decide to put where?</p> <p>You can think of dbt as our assembly line which produces expected outputs every time.</p> <p>You can think of the BI layer as the place where we take the items produced from our assembly line to customize them in order to meet our stakeholder's needs.</p> <p>Your dbt project needs a defined end point! Until the metrics server comes to fruition, you cannot possibly predefine every query or quandary your team might have. So decide as a team where that line is and maintain it.</p>"},{"location":"rules/modeling/#multiple-sources-joined","title":"Multiple Sources Joined","text":"<p><code>fct_multiple_sources_joined</code> (source) shows each instance where a model references more than one source.</p> <p>Example</p> <p><code>model_1</code> references two source tables.</p> <p></p> <p>Reason to Flag</p> <p>We very strongly believe that a staging model is the atomic unit of data modeling. Each staging model bears a one-to-one relationship with the source data table it represents. It has the same granularity, but the columns have been renamed, recast, or usefully reconsidered into a consistent format. With that in mind, two <code>{{ source() }}</code> declarations in one staging model likely means we are not being composable enough and there are individual building blocks which could be broken out into their respective models.</p> <p>Exceptions</p> <p>Sometimes companies have a bunch of identical sources across systems. When these identical sources will only ever be used collectively, you should union them once and create a staging layer on the combined result.</p> <p>To exclude specific cases, check out the instructions in Configuring exceptions to the rules.</p> <p>How to Remediate</p> <p>In this example specifically, those raw sources, <code>source_1.table_1</code> and <code>source_1.table_2</code> should each have their own staging model (<code>stg_model_1</code> and <code>stg_model_2</code>), as transitional steps, which will then be combined into a new <code>int_model_2</code>. Alternatively, you could keep <code>stg_model_2</code> and add <code>base__</code> models as transitional steps.</p> <p>To fix this, try out the codegen package! With this package you can dynamically generate the SQL for a staging (what they call base) model, which you will use to populate <code>stg_model_1</code> and <code>stg_model_2</code> directly from the source data. Create a new model <code>int_model_2</code>. Afterwards, within <code>int_model_2</code>, update your <code>{{ source() }}</code> macros to <code>{{ ref() }}</code> macros and point them to your newly built staging models. If you had type casting, field aliasing, or other simple improvements made in your original <code>stg_model_2</code> SQL, then attempt to move that logic back to the new staging models instead. This will help colocate those transformations and avoid duplicate code, so that all downstream models can leverage the same set of transformations.</p> <p>Post-refactor, your DAG should look like this:</p> <p></p> <p>or if you want to use base_ models and keep stg_model_2 as is:</p> <p></p>"},{"location":"rules/modeling/#rejoining-of-upstream-concepts","title":"Rejoining of Upstream Concepts","text":"<p><code>fct_rejoining_of_upstream_concepts</code> (source) contains all cases where one of the parent's direct children is ALSO the direct child of ANOTHER one of the parent's direct children. Only includes cases where the model \"in between\" the parent and child has NO other downstream dependencies.</p> <p>Example</p> <p><code>stg_model_1</code>, <code>int_model_4</code>, and <code>int_model_5</code> create a \"loop\" in the DAG. <code>int_model_4</code> has no other downstream dependencies other than <code>int_model_5</code>.</p> <p></p> <p>Reason to Flag</p> <p>This could happen for a variety of reasons: Accidentally duplicating some business concepts in multiple data flows, hesitance to touch (and break) someone else\u2019s model, or perhaps trying to snowflake out or modularize everything without awareness of what will help build time.</p> <p>As a general rule, snowflaking out models in a thoughtful manner allows for concurrency, but in this example nothing downstream can run until <code>int_model_4</code> finishes, so it is not saving any time in parallel processing by being its own model. Since both <code>int_model_4</code> and <code>int_model_5</code> depend solely on <code>stg_model_1</code>, there is likely a better way to write the SQL within one model (<code>int_model_5</code>) and simplify the DAG, potentially at the expense of more rows of SQL within the model.</p> <p>Exceptions</p> <p>The one major exception to this would be when using a function from dbt_utils package, such as <code>star</code> or <code>get_column_values</code>, (or similar functions / packages) that require a relation as an argument input. If the shape of the data in the output of <code>stg_model_1</code> is not the same as what you need for the input to the function within <code>int_model_5</code>, then you will indeed need <code>int_model_4</code> to create that relation, in which case, leave it.</p> <p>To exclude specific cases, check out the instructions in Configuring exceptions to the rules.</p> <p>How to Remediate</p> <p>Barring jinja/macro/relation exceptions we mention directly above, to resolve this, simply bring the SQL contents from <code>int_model_4</code> into a CTE within <code>int_model_5</code>, and swap all <code>{{ ref('int_model_4') }}</code> references to the new CTE(s).</p> <p>Post-refactor, your DAG should look like this:</p> <p></p>"},{"location":"rules/modeling/#root-models","title":"Root Models","text":"<p><code>fct_root_models</code> (source) shows each model with 0 direct parents, meaning that the model cannot be traced back to a declared source or model in the dbt project.</p> <p>Example</p> <p><code>model_4</code> has no direct parents</p> <p></p> <p>Reason to Flag</p> <p>This likely means that the model (<code>model_4</code>  below) contains raw table references, either to a raw data source, or another model in the project without using the <code>{{ source() }}</code> or <code>{{ ref() }}</code> functions, respectively. This means that dbt is unable to interpret the correct lineage of this model, and could result in mis-timed execution and/or circular references depending on the model\u2019s upstream dependencies.</p> <p>Exceptions</p> <p>This behavior may be observed in the case of a manually defined reference table that does not have any dependencies. A good example of this is a <code>dim_calendar</code> table that is generated by the <code>{{ dbt_utils.date_spine() }}</code> macro \u2014 this SQL logic is completely self contained, and does not require any external data sources to execute.</p> <p>To exclude specific cases, check out the instructions in Configuring exceptions to the rules.</p> <p>How to Remediate</p> <p>Start by mapping any table references in the <code>FROM</code> clause of the model definition to the models or raw tables that they draw from, and replace those references with the <code>{{ ref() }}</code> if the dependency is another dbt model, or the <code>{{ source() }}</code> function if the table is a raw data source (this may require the declaration of a new source table). Then, visualize this model in the DAG, and refactor as appropriate according to best practices.</p>"},{"location":"rules/modeling/#source-fanout","title":"Source Fanout","text":"<p><code>fct_source_fanout</code> (source) shows each instance where a source is the direct parent of multiple resources in the DAG.</p> <p>Example</p> <p><code>source.table_1</code> has more than one direct child model.</p> <p></p> <p>Reason to Flag</p> <p>Each source node should be referenced by a single model that performs basic operations, such as renaming, recasting, and other light transformations to maintain consistency through out the project. The role of this staging model is to mirror the raw data but align it with project conventions. The staging model should act as a source of truth and a buffer- any model which depends on the data from a given source should reference the cleaned data in the staging model as opposed to referencing the source directly. This approach keeps the code DRY (any light transformations that need to be done on the raw data are performed only once). Minimizing references to the raw data will also make it easier to update the project should the format of the raw data change.</p> <p>Exceptions</p> <p>NoSQL databases or heavily nested data sources often have so much info json packed into a table that you need to break one raw data source into multiple base models.</p> <p>To exclude specific cases, check out the instructions in Configuring exceptions to the rules.</p> <p>How to Remediate</p> <p>Create a staging model which references the source and cleans the raw data (e.g. renaming, recasting). Any models referencing the source directly should be refactored to point towards the staging model instead.</p> <p>After refactoring the above example, the DAG would look something like this:</p> <p></p>"},{"location":"rules/modeling/#staging-models-dependent-on-downstream-models","title":"Staging Models Dependent on Downstream Models","text":"<p><code>fct_staging_dependent_on_marts_or_intermediate</code> (source) shows each staging model that depends on an intermediate or marts model, as defined by the naming conventions and folder paths specified in your project variables.</p> <p>Example</p> <p><code>stg_model_5</code>, a staging model, builds from <code>fct_model_9</code> a marts model.</p> <p></p> <p>Reason to Flag</p> <p>This likely represents a misnamed file. According to dbt best practices, staging models should only select from source nodes. Dependence on downstream models indicates that this model may need to be either renamed, or reconfigured to only select from source nodes.</p> <p>How to Remediate</p> <p>Rename the file in the <code>child</code> column to use to appropriate prefix, or change the models lineage by pointing the staging model to the appropriate <code>{{ source() }}</code>.</p> <p>After updating the model to use the appropriate <code>{{ source() }}</code> function, your graph should look like this:</p> <p></p>"},{"location":"rules/modeling/#staging-models-dependent-on-other-staging-models","title":"Staging Models Dependent on Other Staging Models","text":"<p><code>fct_staging_dependent_on_staging</code> (source) shows each parent/child relationship where models in the staging layer are dependent on each other.</p> <p>Example</p> <p><code>stg_model_2</code> is a parent of <code>stg_model_4</code>.</p> <p></p> <p>Reason to Flag</p> <p>This may indicate a change in naming is necessary, or that the child model should instead reference a source.</p> <p>How to Remediate</p> <p>You should either change the model type of the <code>child</code> (maybe to an intermediate or marts model) or change the child's lineage instead reference the appropriate <code>{{ source() }}</code>.</p> <p>In our example, we might realize that <code>stg_model_4</code> is actually an intermediate model. We should move this file to the appropriate intermediate directory and update the file name to <code>int_model_4</code>.</p>"},{"location":"rules/modeling/#unused-sources","title":"Unused Sources","text":"<p><code>fct_unused_sources</code> (source) shows each source with 0 children.</p> <p>Example</p> <p><code>source.table_4</code> isn't being referenced.</p> <p></p> <p>Reason to Flag</p> <p>This represents either a source that you have defined in YML but never brought into a model or a model that was deprecated and the corresponding rows in the source block of the YML file were not deleted at the same time. This simply represents the buildup of cruft in the project that doesn\u2019t need to be there.</p> <p>How to Remediate</p> <p>Navigate to the <code>sources.yml</code> file (or whatever your company has called the file) that corresponds to the unused source. Within the YML file, remove the unused table name, along with descriptions or any other nested information.</p> sources.yml<pre><code>sources:\n  - name: some_source\n    database: raw\n    tables:\n      - name: table_1\n      - name: table_2\n      - name: table_3\n      - name: table_4  # &lt;-- remove this line\n</code></pre> <p></p>"},{"location":"rules/modeling/#models-with-too-many-joins","title":"Models with Too Many Joins","text":"<p><code>fct_too_many_joins</code> (source) shows models with a reference to too many other models or sources.</p> <p>The number of different references to start raising errors is set to 7 by default, but you can set your own threshold by overriding the <code>too_many_joins_threshold</code> variable. See overriding variables section.</p> <p>Example</p> <p><code>fct_model_1</code> directly references seven (7) staging models upstream.</p> <p></p> <p>Reason to Flag</p> <p>This likely represents a model in which too much is being done. Having a model that too many upstream models introduces a lot of code complexity, which can be challenging to understand and maintain.</p> <p>How to Remediate</p> <p>Bringing together a reasonable number (typically 4 to 6) of entities or concepts (staging models, or perhaps other intermediate models) that will be joined with another similarly purposed intermediate model to generate a mart. Rather than having too many joins, we can join two intermediate models that each house a piece of the complexity, giving us increased readability, flexibility, testing surface area, and insight into our components.</p> <p></p>"},{"location":"rules/performance/","title":"Performance","text":""},{"location":"rules/performance/#chained-view-dependencies","title":"Chained View Dependencies","text":"<p><code>fct_chained_views_dependencies</code> (source) contains models that are dependent on chains of \"non-physically-materialized\" models (views and ephemerals), highlighting potential cases for improving performance by switching the materialization of model(s) within the chain to table or incremental.</p> <p>This model will raise a <code>warn</code> error on a <code>dbt build</code> or <code>dbt test</code> if the <code>distance</code> between a given <code>parent</code> and <code>child</code> is greater than or equal to 4. You can set your own threshold for chained views by overriding the <code>chained_views_threshold</code> variable. See overriding variables section.</p> <p>Example</p> <p><code>table_1</code> depends on a chain of 4 views (<code>view_1</code>, <code>view_2</code>, <code>view_3</code>, and <code>view_4</code>).</p> <p></p> <p>Reason to Flag</p> <p>You may experience a long runtime for a model when it is build on top of a long chain of \"non-physically-materialized\" models (views and ephemerals). In the example above, nothing is really computed until you get to <code>table_1</code>. At which point, it is going to run the query within <code>view_4</code>, which will then have to run the query within <code>view_3</code>, which will then have the run the query within <code>view_2</code>, which will then have to run the query within <code>view_1</code>. These will all be running at the same time, which creates a long runtime for <code>table_1</code>.</p> <p>How to Remediate</p> <p>We can reduce this compilation time by changing the materialization strategy of some key upstream models to table or incremental to keep a minimum amount of compute in memory and preventing nesting of views. If, for example, we change the materialization of <code>view_4</code> from a view to a table, <code>table_1</code> will have a shorter runtime as it will have less compilation to do.</p> <p>The best practice to determine top candidates for changing materialization from <code>view</code> to <code>table</code>:</p> <ul> <li>if a view is used downstream my many models, change materialization to table</li> <li>if a view has more complex calculations (window functions, joins between many tables, etc.), change materialization to table</li> </ul>"},{"location":"rules/performance/#exposure-parents-materializations","title":"Exposure Parents Materializations","text":"<p><code>fct_exposure_parents_materializations</code> (source) highlights instances where the resources referenced by exposures are either:</p> <ol> <li>a <code>source</code></li> <li>a <code>model</code> that does not use the <code>table</code> or <code>incremental</code> materialization</li> </ol> <p>Example</p> <p></p> <p>In this case, the parents of <code>exposure_1</code> are not both materialized as tables -- <code>dim_model_7</code> is ephemeral, while <code>fct_model_6</code> is a table. This model would return a record for the <code>dim_model_7 --&gt; exposure_1</code> relationship.</p> <p>Reason to Flag</p> <p>Exposures should depend on the business logic you encoded into your dbt project (e.g. models or metrics) rather than raw untransformed sources. Additionally, models that are referenced by an exposure are likely to be used heavily in downstream systems, and therefore need to be performant when queried.</p> <p>How to Remediate</p> <p>If you have a source parent of an exposure, you should incorporate that raw data into your project in some way, then update the exposure to point to that model.</p> <p>If necessary, update the <code>materialized</code> configuration on the models returned in <code>fct_exposure_parents_materializations</code> to either <code>table</code> or <code>incremental</code>. This can be done in individual model files using a config block, or for groups of models in your <code>dbt_project.yml</code> file. See the docs on model configurations for more info!</p>"},{"location":"rules/structure/","title":"Structure","text":""},{"location":"rules/structure/#model-naming-conventions","title":"Model Naming Conventions","text":"<p><code>fct_model_naming_conventions</code> (source) shows all cases where a model does NOT have the appropriate prefix.</p> <p>Example</p> <p>Consider <code>model_8</code> which is nested in the <code>marts</code> subdirectory:</p> <pre><code>\u251c\u2500\u2500 dbt_project.yml\n\u2514\u2500\u2500 models\n    \u251c\u2500\u2500 marts\n        \u2514\u2500\u2500 model_8.sql\n</code></pre> <p>This model should be renamed to either <code>fct_model_8</code> or <code>dim_model_8</code>.</p> <p>Reason to Flag</p> <p>Without appropriate naming conventions, a user querying the data warehouse might incorrectly assume the model type of a given relation. In order to explicitly name the model type in the data warehouse, we recommend appropriately prefixing your models in dbt.</p> Model Type Appropriate Prefixes Staging <code>stg_</code> Intermediate <code>int_</code> Marts <code>fct_</code> or <code>dim_</code> Other <code>rpt_</code> <p>How to Remediate</p> <p>For each model flagged, ensure the model type is defined and the model name is prefixed appropriately.</p>"},{"location":"rules/structure/#model-directories","title":"Model Directories","text":"<p><code>fct_model_directories</code> (source) shows all cases where a model is NOT in the appropriate subdirectory:</p> <ul> <li>For staging models: The files should be nested in the staging folder of a subfolder that matches their source parent's name.</li> <li>For non-staging models: The files should be nested closest to the folder name that matches their model type.  </li> </ul> <p>Example</p> <p>Consider <code>stg_model_3</code> which is a staging model for <code>source_2.table_3</code>:</p> <p></p> <p>But, <code>stg_model_3.sql</code> is inappropriately nested in the subdirectory <code>source_1</code>:</p> <pre><code>\u251c\u2500\u2500 dbt_project.yml\n\u2514\u2500\u2500 models\n    \u251c\u2500\u2500 marts\n    \u2514\u2500\u2500 staging\n        \u2514\u2500\u2500 source_1\n            \u251c\u2500\u2500 stg_model_3.sql\n</code></pre> <p>This file should be moved into the subdirectory <code>source_2</code>:</p> <pre><code>\u251c\u2500\u2500 dbt_project.yml\n\u2514\u2500\u2500 models\n    \u251c\u2500\u2500 marts\n    \u2514\u2500\u2500 staging\n        \u251c\u2500\u2500 source_1\n        \u2514\u2500\u2500 source_2\n            \u251c\u2500\u2500 stg_model_3.sql\n</code></pre> <p>Consider <code>dim_model_7</code> which is a marts model but is inappropriately nested closest to the subdirectory <code>intermediate</code>:</p> <pre><code>\u251c\u2500\u2500 dbt_project.yml\n\u2514\u2500\u2500 models\n    \u2514\u2500\u2500 marts\n        \u2514\u2500\u2500 intermediate\n            \u251c\u2500\u2500 dim_model_7.sql\n</code></pre> <p>This file should be moved closest to the subdirectory <code>marts</code>:</p> <pre><code>\u251c\u2500\u2500 dbt_project.yml\n\u2514\u2500\u2500 models\n    \u2514\u2500\u2500 marts\n        \u251c\u2500\u2500 dim_model_7.sql\n</code></pre> <p>Consider <code>int_model_4</code> which is an intermediate model but is inappropriately nested closest to the subdirectory <code>marts</code>:</p> <pre><code>\u251c\u2500\u2500 dbt_project.yml\n\u2514\u2500\u2500 models\n    \u2514\u2500\u2500 marts\n        \u251c\u2500\u2500 int_model_4.sql\n</code></pre> <p>This file should be moved closest to the subdirectory <code>intermediate</code>:</p> <pre><code>\u251c\u2500\u2500 dbt_project.yml\n\u2514\u2500\u2500 models\n    \u2514\u2500\u2500 marts\n        \u2514\u2500\u2500 intermediate\n            \u251c\u2500\u2500 int_model_4.sql\n</code></pre> <p>Reason to Flag</p> <p>Because we often work with multiple data sources, in our staging directory, we create one subdirectory per source.</p> <pre><code>\u251c\u2500\u2500 dbt_project.yml\n\u2514\u2500\u2500 models\n    \u251c\u2500\u2500 marts\n    \u2514\u2500\u2500 staging\n        \u251c\u2500\u2500 braintree\n        \u2514\u2500\u2500 stripe\n</code></pre> <p>Each staging directory contains:</p> <ul> <li>One staging model for each raw source table</li> <li>One .yml file which contains source definitions, tests, and documentation (see Source Directories)</li> <li>One .yml file which contains tests &amp; documentation for models in the same directory (see Test Directories)</li> </ul> <p>This provides for clear repository organization, so that analytics engineers can quickly and easily find the information they need.</p> <p>We might create additional folders for intermediate models but each file should always be nested closest to the folder name that matches their model type.</p> <pre><code>\u251c\u2500\u2500 dbt_project.yml\n\u2514\u2500\u2500 models\n    \u2514\u2500\u2500 marts\n        \u2514\u2500\u2500 fct_model_6.sql\n        \u2514\u2500\u2500 intermediate\n            \u2514\u2500\u2500 int_model_5.sql\n</code></pre> <p>How to Remediate</p> <p>For each resource flagged, move the file from the <code>current_file_path</code> to <code>change_file_path_to</code>.</p>"},{"location":"rules/structure/#source-directories","title":"Source Directories","text":"<p><code>fct_source_directories</code> (source) shows all cases where a source definition is NOT in the appropriate subdirectory:</p> <p>Example</p> <p>Consider <code>source_2.table_3</code> which is a <code>source_2</code> source but it had been defined inappropriately in a <code>source.yml</code> file nested in the subdirectory <code>source_1</code>:</p> <pre><code>\u251c\u2500\u2500 dbt_project.yml\n\u2514\u2500\u2500 models\n    \u251c\u2500\u2500 marts\n    \u2514\u2500\u2500 staging\n        \u2514\u2500\u2500 source_1\n            \u251c\u2500\u2500 source.yml\n</code></pre> <p>This definition should be moved into a <code>source.yml</code> file nested in the subdirectory <code>source_2</code>:</p> <pre><code>\u251c\u2500\u2500 dbt_project.yml\n\u2514\u2500\u2500 models\n    \u251c\u2500\u2500 marts\n    \u2514\u2500\u2500 staging\n        \u251c\u2500\u2500 source_1\n        \u2514\u2500\u2500 source_2\n            \u251c\u2500\u2500 source.yml\n</code></pre> <p>Reason to Flag</p> <p>Because we often work with multiple data sources, in our staging directory, we create one subdirectory per source.</p> <pre><code>\u251c\u2500\u2500 dbt_project.yml\n\u2514\u2500\u2500 models\n    \u251c\u2500\u2500 marts\n    \u2514\u2500\u2500 staging\n        \u251c\u2500\u2500 braintree\n        \u2514\u2500\u2500 stripe\n</code></pre> <p>Each staging directory contains:</p> <ul> <li>One staging model for each raw source table (see Model Directories)</li> <li>One .yml file which contains source definitions, tests, and documentation</li> <li>One .yml file which contains tests &amp; documentation for models in the same directory (see Test Directories)</li> </ul> <p>This provides for clear repository organization, so that analytics engineers can quickly and easily find the information they need.</p> <p>How to Remediate</p> <p>For each source flagged, move the file from the <code>current_file_path</code> to <code>change_file_path_to</code>.</p>"},{"location":"rules/structure/#test-directories","title":"Test Directories","text":"<p><code>fct_test_directories</code> (source) shows all cases where model tests are NOT in the same subdirectory as the corresponding model.</p> <p>Example</p> <p><code>int_model_4</code> is located within <code>marts/</code>. However, tests for <code>int_model_4</code> are configured in <code>staging/staging.yml</code>:</p> <pre><code>\u251c\u2500\u2500 dbt_project.yml\n\u2514\u2500\u2500 models\n    \u2514\u2500\u2500 marts\n        \u251c\u2500\u2500 int_model_4.sql\n    \u2514\u2500\u2500 staging\n        \u251c\u2500\u2500 staging.yml\n</code></pre> <p>A new yml file should be created in <code>marts/</code> which contains all tests and documentation for <code>int_model_4</code>, and for the rest of the models in located in the <code>marts/</code> directory:</p> <pre><code>\u251c\u2500\u2500 dbt_project.yml\n\u2514\u2500\u2500 models\n    \u2514\u2500\u2500 marts\n        \u251c\u2500\u2500 int_model_4.sql\n        \u251c\u2500\u2500 marts.yml\n    \u2514\u2500\u2500 staging\n        \u251c\u2500\u2500 staging.yml\n</code></pre> <p>Reason to Flag</p> <p>Each subdirectory in <code>models/</code> should contain one .yml file that includes the tests and documentation for all models within the given subdirectory. Keeping your repository organized in this way ensures that folks can quickly access the information they need.</p> <p>How to Remediate</p> <p>Move flagged tests from the yml file under <code>current_test_directory</code> to the yml file under <code>change_test_directory_to</code> (create a new yml file if one does not exist).</p>"},{"location":"rules/testing/","title":"Testing","text":""},{"location":"rules/testing/#missing-primary-key-tests","title":"Missing Primary Key Tests","text":"<p><code>fct_missing_primary_key_tests</code> (source) lists every model that does not meet the minimum testing requirement of testing primary keys. Any model that does not have either</p> <ol> <li>a <code>not_null</code> test and a <code>unique</code> test applied to a single column OR</li> <li>a <code>dbt_utils.unique_combination_of_columns</code> test applied to a set of columns OR</li> <li>a <code>not_null</code> constraint and a <code>unique</code> test applied to a single column</li> </ol> <p>will be flagged by this model.</p> <p>Reason to Flag</p> <p>Tests are assertions you make about your models and other resources in your dbt project (e.g. sources, seeds and snapshots). Defining tests is a great way to confirm that your code is working correctly, and helps prevent regressions when your code changes. Models without proper tests on their grain are a risk to the reliability and scalability of your project.</p> <p>How to Remediate</p> <p>Apply a uniqueness test and a not null test to the column that represents the grain of your model in its schema entry. For contracted models, optionally replace the not null test with the not null constraint. For models that are unique across a combination of columns, we recommend adding a surrogate key column to your model, then applying these tests to that new model. See the <code>surrogate_key</code> macro from dbt_utils for more info! Alternatively, you can use the <code>dbt_utils.unique_combination_of_columns</code> test from <code>dbt_utils</code>. Check out the overriding variables section to read more about configuring other primary key tests for your project!</p> <p>Additional tests can be configured by applying a generic test in the model's <code>.yml</code> entry or by creating a singular test in the <code>tests</code> directory of you project.</p> <p>Enforcing on more node types(Advanced)</p> <p>You can optionally extend this test to apply to more node types (<code>source</code>,<code>snapshot</code>, <code>seed</code>). By configuring the variable <code>enforced_primary_key_node_types</code> to be a set of node types for which you wish to enforce primary key test coverage in addition to (or instead of) just models. Check out the overriding variables section for instructions</p> <p>Snapshots should always have a multi-field primary key in order to function, while sources and seeds may not. Depending on your expectations for duplicates and null values, different kinds of primary key tests may be appropriate. Consider your use case carefully.</p>"},{"location":"rules/testing/#missing-source-freshness","title":"Missing Source Freshness","text":"<p><code>fct_sources_without_freshness</code> (source) lists every source that does not have a source freshness threshold defined. Any source that does not have one or both of warn_after and error_after will be flagged by this model.</p> <p>Reason to Flag</p> <p>Source freshness is useful for understanding if your data pipelines are in a healthy state and is a critical component of defining SLAs for your warehouse. Enabling freshness for sources also facilitates referencing the source freshness results in the selectors for a more efficient execution. </p> <p>How to Remediate</p> <p>Apply a source freshness block to the source definition. This can be implemented at either the source name or table name level.</p>"},{"location":"rules/testing/#test-coverage","title":"Test Coverage","text":"<p><code>fct_test_coverage</code> (source) contains metrics pertaining to project-wide test coverage. Specifically, this models measures:</p> <ol> <li><code>test_coverage_pct</code>: the percentage of your models that have minimum 1 test applied.</li> <li><code>test_to_model_ratio</code>: the ratio of the number of tests in your dbt project to the number of models in your dbt project</li> <li><code>&lt;model_type&gt;_test_coverage_pct</code>: the percentage of each of your model types that have minimum 1 test applied.</li> </ol> <p>This model will raise a <code>warn</code> error on a <code>dbt build</code> or <code>dbt test</code> if the <code>test_coverage_pct</code> is less than 100%. You can set your own threshold by overriding the <code>test_coverage_target</code> variable. You can adjust your own model types by overriding the <code>model_types</code> variable. See overriding variables section.</p> <p>Reason to Flag We recommend that every model in your dbt project has tests applied to ensure the accuracy of your data transformations.</p> <p>How to Remediate</p> <p>Apply a generic test in the model's <code>.yml</code> entry, or create a singular test in the <code>tests</code> directory of you project.</p> <p>As explained above, we recommend at a minimum, every model should have <code>not_null</code> and <code>unique</code> tests set up on a primary key.</p>"}]}